---
interface CursorEffectsProps {
  pixelColor?: string;
  pixelMinSize?: number;
  pixelMaxSize?: number;
  pixelLifeMs?: number;
  pixelPerMove?: number;
  sparkColors?: string[];
  sparkCount?: number;
  sparkLifeMs?: number;
  sparkSpeed?: number;
  enabled?: boolean;
  hideSystemCursor?: boolean;
  showCursorDot?: boolean;
  cursorDotSize?: number;
  cursorDotColor?: string;
  cursorDotShape?: 'square' | 'circle' | 'crosshair';
  crosshairSize?: number;
  crosshairThickness?: number;
  crosshairGap?: number;
}

const {
  pixelColor,
  pixelMinSize,
  pixelMaxSize,
  pixelLifeMs,
  pixelPerMove,
  sparkColors,
  sparkCount,
  sparkLifeMs,
  sparkSpeed,
  enabled,
  hideSystemCursor,
  showCursorDot,
  cursorDotSize,
  cursorDotColor,
  cursorDotShape,
  crosshairSize,
  crosshairThickness,
  crosshairGap,
} = Astro.props;

const dotSize = cursorDotSize ?? 8;
const dotColor = cursorDotColor ?? (pixelColor ?? "#ffffff");
const cursorShape = cursorDotShape ?? 'square';
const isCircle = cursorShape === 'circle';
const isCrosshair = cursorShape === 'crosshair';
---

<div class="pointer-events-none fixed inset-0 z-[60] select-none">
  <canvas class="cursor-effects-canvas h-full w-full block" />
  {showCursorDot && !isCrosshair && (
    <div
      class="cursor-dot absolute top-0 left-0 will-change-transform"
      style={{
        width: dotSize,
        height: dotSize,
        backgroundColor: dotColor,
        borderRadius: isCircle ? '9999px' : '0',
        transform: 'translate3d(-9999px, -9999px, 0)'
      }}
    />
  )}
  {isCrosshair && (
    <div
      class="cursor-crosshair absolute top-0 left-0 will-change-transform"
      style={{
        width: (crosshairSize ?? 8) * 2,
        height: (crosshairSize ?? 8) * 2,
        transform: 'translate3d(-9999px, -9999px, 0)'
      }}
    >
      {/* Vertical bar */}
      <div
        class="absolute"
        style={{
          left: (crosshairSize ?? 8) - (crosshairThickness ?? 2) / 2,
          top: 0,
          width: crosshairThickness ?? 2,
          height: (crosshairSize ?? 8) - (crosshairGap ?? 2),
          backgroundColor: dotColor
        }}
      />
      <div
        class="absolute"
        style={{
          left: (crosshairSize ?? 8) - (crosshairThickness ?? 2) / 2,
          top: (crosshairSize ?? 8) + (crosshairGap ?? 2),
          width: crosshairThickness ?? 2,
          height: (crosshairSize ?? 8) - (crosshairGap ?? 2),
          backgroundColor: dotColor
        }}
      />
      {/* Horizontal bar */}
      <div
        class="absolute"
        style={{
          top: (crosshairSize ?? 8) - (crosshairThickness ?? 2) / 2,
          left: 0,
          height: crosshairThickness ?? 2,
          width: (crosshairSize ?? 8) - (crosshairGap ?? 2),
          backgroundColor: dotColor
        }}
      />
      <div
        class="absolute"
        style={{
          top: (crosshairSize ?? 8) - (crosshairThickness ?? 2) / 2,
          left: (crosshairSize ?? 8) + (crosshairGap ?? 2),
          height: crosshairThickness ?? 2,
          width: (crosshairSize ?? 8) - (crosshairGap ?? 2),
          backgroundColor: dotColor
        }}
      />
    </div>
  )}
</div>

<script define:vars={{
  pixelColor,
  pixelMinSize,
  pixelMaxSize,
  pixelLifeMs,
  pixelPerMove,
  sparkColors,
  sparkCount,
  sparkLifeMs,
  sparkSpeed,
  enabled,
  hideSystemCursor,
  showCursorDot,
  cursorDotSize,
  cursorDotColor,
  cursorDotShape,
  crosshairSize,
  crosshairThickness,
  crosshairGap,
}}>
  const canvas = document.querySelector('.cursor-effects-canvas');
  const dotRef = document.querySelector('.cursor-dot');
  const crossRef = document.querySelector('.cursor-crosshair');

  let animationRef = null;

  const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  const isFinePointer = window.matchMedia("(pointer: fine)").matches;
  const isTouchDevice = navigator.maxTouchPoints > 0;

  const isEnabled = enabled ?? (isFinePointer && !isTouchDevice && !prefersReducedMotion);
  if (!isEnabled) return;

  if (!canvas) return;
  const ctx = canvas.getContext("2d", { alpha: true });
  if (!ctx) return;

  let devicePixelRatioValue = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  const state = {
    width: 0,
    height: 0,
    pixels: [],
    sparks: [],
    lastMoveTs: 0
  };

  const cfg = {
    pixelColor: pixelColor ?? "#8b5cf6", // violet-500
    pixelMinSize: pixelMinSize ?? 3,
    pixelMaxSize: pixelMaxSize ?? 8,
    pixelLifeMs: pixelLifeMs ?? 350,
    pixelPerMove: pixelPerMove ?? 3,
    sparkColors: sparkColors ?? ["#22d3ee", "#a78bfa", "#f472b6", "#34d399"],
    sparkCount: sparkCount ?? 14,
    sparkLifeMs: sparkLifeMs ?? 550,
    sparkSpeed: sparkSpeed ?? 2.2
  };

  const cursorCfg = {
    hideSystemCursor: hideSystemCursor ?? false,
    showCursorDot: showCursorDot ?? false,
    cursorDotSize: cursorDotSize ?? 8,
    cursorDotColor: cursorDotColor ?? (pixelColor ?? "#ffffff"),
    cursorDotShape: cursorDotShape ?? 'square',
    crosshairSize: crosshairSize ?? 8,
    crosshairThickness: crosshairThickness ?? 2,
    crosshairGap: crosshairGap ?? 2
  };

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    state.width = Math.floor(rect.width);
    state.height = Math.floor(rect.height);
    canvas.width = Math.floor(state.width * devicePixelRatioValue);
    canvas.height = Math.floor(state.height * devicePixelRatioValue);
    ctx.setTransform(devicePixelRatioValue, 0, 0, devicePixelRatioValue, 0, 0);
  }

  function randomBetween(min, max) {
    return Math.random() * (max - min) + min;
  }

  function addPixel(x, y) {
    state.pixels.push({
      x: x + randomBetween(-2, 2),
      y: y + randomBetween(-2, 2),
      size: randomBetween(cfg.pixelMinSize, cfg.pixelMaxSize),
      birthTs: performance.now(),
      lifeMs: cfg.pixelLifeMs,
      hueShift: Math.floor(randomBetween(-12, 12))
    });
  }

  function addClickSparks(x, y) {
    for (let i = 0; i < cfg.sparkCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = cfg.sparkSpeed * (0.6 + Math.random() * 0.8);
      const size = randomBetween(1.5, 3.5);
      const color = cfg.sparkColors[Math.floor(Math.random() * cfg.sparkColors.length)];
      state.sparks.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size,
        birthTs: performance.now(),
        lifeMs: cfg.sparkLifeMs,
        color
      });
    }
  }

  function onPointerMove(ev) {
    const now = performance.now();
    const throttle = now - state.lastMoveTs < 8;
    state.lastMoveTs = now;
    const x = ev.clientX;
    const y = ev.clientY;
    const count = throttle ? Math.max(1, Math.floor(cfg.pixelPerMove / 2)) : cfg.pixelPerMove;
    for (let i = 0; i < count; i++) addPixel(x, y);

    if (cursorCfg.showCursorDot && dotRef) {
      const s = cursorCfg.cursorDotSize;
      dotRef.style.transform = `translate3d(${x - s / 2}px, ${y - s / 2}px, 0)`;
    }
    if (cursorCfg.cursorDotShape === 'crosshair' && crossRef) {
      const size = cursorCfg.crosshairSize;
      crossRef.style.transform = `translate3d(${x - size}px, ${y - size}px, 0)`;
    }
  }

  function onClick(ev) {
    addClickSparks(ev.clientX, ev.clientY);
  }

  function step() {
    ctx.clearRect(0, 0, state.width, state.height);

    const now = performance.now();

    for (let i = state.pixels.length - 1; i >= 0; i--) {
      const p = state.pixels[i];
      const t = (now - p.birthTs) / p.lifeMs;
      if (t >= 1) {
        state.pixels.splice(i, 1);
        continue;
      }
      const alpha = 1 - t;
      const size = p.size * (0.8 + 0.2 * (1 - t));
      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = cfg.pixelColor;
      ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
    }

    for (let i = state.sparks.length - 1; i >= 0; i--) {
      const s = state.sparks[i];
      const t = (now - s.birthTs) / s.lifeMs;
      if (t >= 1) {
        state.sparks.splice(i, 1);
        continue;
      }
      const alpha = 1 - t;
      s.vx *= 0.985;
      s.vy = s.vy * 0.985 + 0.03;
      s.x += s.vx;
      s.y += s.vy;

      const size = s.size * (0.9 + 0.1 * (1 - t));
      ctx.globalAlpha = alpha;
      ctx.fillStyle = s.color;
      ctx.fillRect(s.x - size / 2, s.y - size / 2, size, size);
    }

    ctx.globalAlpha = 1;
    animationRef = requestAnimationFrame(step);
  }

  const onResize = () => {
    devicePixelRatioValue = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    resizeCanvas();
  };

  if (cursorCfg.hideSystemCursor) {
    document.body.classList.add('cursor-none');
  }
  resizeCanvas();
  window.addEventListener("resize", onResize);
  window.addEventListener("pointermove", onPointerMove, { passive: true });
  window.addEventListener("click", onClick, { passive: true });
  animationRef = requestAnimationFrame(step);

  document.addEventListener('astro:before-swap', () => {
    if (animationRef) cancelAnimationFrame(animationRef);
    window.removeEventListener("resize", onResize);
    window.removeEventListener("pointermove", onPointerMove);
    window.removeEventListener("click", onClick);
    if (cursorCfg.hideSystemCursor) {
      document.body.classList.remove('cursor-none');
    }
  }, { once: true });
</script>
